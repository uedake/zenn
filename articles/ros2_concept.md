---
title: "ROS2を理解する上でのポイント"
emoji: "📘"
type: "tech"
topics:
  - "ros2"
  - "robot"
  - "robotics"
published: true
published_at: "2023-09-03 22:13"
---

# 解説対象

本記事では、ROS2を理解する上で頭にいれておいた方がよい基本概念を説明します。

本記事は下記の「ROS2を深く理解する」の記事群の一部ですが、この記事単独でも理解できるようになっています。

https://zenn.dev/uedake/articles/ros2_collection

# 前提
- 調査はROS2 humble時の実装に基づいていますが、基本的にdistributionに依存しない内容です。
- 調査はc++側の実装（rclcpp）に基づいていますが、基本的にクライアント言語に依存しない内容です。

# 公式ドキュメント

- [Concepts](https://docs.ros.org/en/humble/Concepts/Basic.html)
  - かなりあっさりで物足りません

# 参考情報

- [ROS2に関する基本情報](https://qiita.com/NeK/items/18ff9e9c443295d5d805)
  - よくまとまっています
- [駆け抜けるROS2](https://zenn.dev/hakuturu583/articles/ros2_turtorial)
  - ROS2ではノードをcomponent形式で開発すべきことが解説されている
- [ROS 2のAPIの使い方](https://gbiggs.github.io/rosjp_ros2_intro/ros2_basics.html)
  - ノード周りの詳細な解説がありますが、特にexecutorの理解の参考になります
- [ROS 2のプロセス内（intra-process）通信を理解する](https://www.youtalk.jp/2017/06/05/ros2-intra-process.html)
  - パフォーマンスを上げるのに理解必須のプロセス内通信についての参考になります
- [ROS2でプロセス内通信によるゼロコピーを試す](https://qiita.com/shigeharu_shibahata/items/0c5fb3963150403af57c)
  - パフォーマンスを上げるにはゼロコピーの理解も必要

# ROS2におけるプログラミングとは

本記事は、ROS2におけるプログラミングスタイルが複数あることを理解するのが目的です。

ROS2におけるプログラミングは、カジュアルな（＝ほとんどプログラミングしない）スタイルからゴリゴリの大規模開発スタイルまで、幅広く使える汎用性と拡張性を備えています。カジュアルな順番に開発スタイルを並べてみると下記のような雰囲気です。

| スタイル | 独自パッケージの開発 | 独自executableの開発 | カスタムノードクラスの開発 | 説明 |
| ---- | ---- | ---- | ---- | ---- | 
| 既存パッケージ利用のみ | × | × | × | 既存パッケージで足りる場合は、パッケージを利用する為の設定である、launchファイル、ノードパラメータ設定ファイル（configファイル）だけをつくれば良いです。作成したlaunchファイル等は必ずしもパッケージ化しなくても構いません |
| launchパッケージ開発のみ | 〇 | × | × | ほとんど上記と変わりませんが、launchファイルを誰でも使えるように配布する場合パッケージ化しましょう|
| 独自処理パッケージ開発（シンプル） | 〇 | 〇 | × | 実際には多くのケースで既存パッケージの利用だけでは望むシステムは作れないので、独自処理を行えるようexecutableを作成します。独自処理を実装するにあたり、ROS2が提供する`Node`クラスや`LifecycleNode`クラスを使うだけでどうにかなる場合はカスタムノードクラスを作成する必要はありません。しかし、独自処理が`Node`や`LifecycleNode`の中にカプセル化されずexecutable上に実装されることになるため、複雑なシステムには向きません|
| 独自処理パッケージ開発（カスタムノードクラスあり） | 〇 | 〇 | 〇 | 複雑なシステムをつくる場合、ROS2が提供する`Node`や`LifecycleNode`を直接使うのでなく、それらを継承したカスタムノードクラスを実装し使用したくなります。カスタムノードクラスを作れば独自処理を中に埋め込め、オブジェクト指向で機能を実装でき、見通しが良くなります。カスタムノードクラスは直接executable上に定義せずlibraryに分離して定義するのが推奨です|

以下では上記を理解する為の概念を説明していきます

# ROS2を理解する上でのポイント

概念として、配布単位（package）、プログラム実行単位（executable/library）、論理処理単位（ノード）をちゃんと区別して把握することが重要です。

通常ROS2を用いたロボットシステムは、複数のpackageに含まれる複数のexecutableを実行することで複数のノードを生成し動作します。

- ソフトウェアは、ファイル群としての存在であるpackageを単位として配布されます
  - packageは、機能を実現する為の一連のプログラム（executable/library）ファイルや各種リソースファイル一式を提供します
- ソフトウェアは、ファイルとしての存在であるexecutableを単位として実行します
  - executableは、直接実行可能なプログラムを提供します。基本的にはノードを生成し動作させる役目を果たします
  - libraryは、他のexecutableから読み込まれて間接的に実行されるプログラムを提供します。libraryは他のexecutableにロードされ実行されます。例えばlibraryで定義しているノードクラスは、libraryをロードしたexecutable上で使用できるようになります
- ソフトウェアは、論理的な存在であるノードを単位として処理を行います
  - ノードは、情報を所定のルールに従って入力・処理・出力します

下記で重要なポイントに絞って説明していきます。

# ノードとは

- ノードは、ROS2上で実行する処理を担うオブジェクト（論理処理単位）です
  - ノードは、executable上でノードクラスをインスタンス化して生成します
- 標準ノードクラスとカスタムノードクラス
  - ROS2には、標準ノードクラス（`Node`クラスもしくは`LifecycleNode`クラス）が定義されています。独自の処理を持ったノードを作るためにこれら標準ノードクラスをそのまま使用してもよいですが、標準ノードクラスを継承したクラス（＝カスタムノードノード）を作成して使用してもよいです
  - 使い分け
    - 独自処理のコードをカプセル化したいならカスタムノードクラスを作成します
    - ライフサイクルイベントのハンドリングをする場合は、カスタムノードクラスを作成します
    - どちらも不要であれば、標準ノードクラスを直接用います
      - ただしこの場合独自処理（例えば、ノードにserviceサーバーを追加しserviceがコールされた時の処理を実装する）は、ノードクラス外（例えばexecutableで実行される関数中）に記述することになり、オブジェクト指向の考え方からすると全容を捉えにくい構成になることに注意
  - カスタムノードクラスを作成する場合のベストプラクティス
    - カスタムノードクラスの定義は、executable中で定義することもlibrary中で定義することもどちらも可能であるが、下記を推奨
      - library中でcomponent形式で定義する
      - executable側からlibrary中のカスタムノードクラスをロードして利用する
    - カスタムノードクラスを特定のexecutableに密結合させずに分離することで柔軟な運用が可能になります

## ノードを動かす手段

- ノードは必ずexecutor上で動く
  - `rclcpp:spin(node)`で実行した場合でも、内部で`SingleThreadedExecutor`が生成されその中でノードが動いています
- ノードを動かすexecutorの実行を開始する方法は以下のどちらか
  - ノードを動かす処理を記述したexecutableを実行することでノードの処理を開始する
  - ノードを動かす処理を記述したlibraryをロードするexecutableを実行することでノードの処理を開始する

例えば、c++から他のプログラムファイルで定義されたカスタムノードクラス（`my_namespace::MyNode`）を動かす場合

```cpp
rclcpp::executors::SingleThreadedExecutor exec;
auto my_node = std::make_shared<my_namespace::MyNode>(options);
exec.add_node(my_node);
```

## ノードの情報交換方法

ノードは下記の間での情報のやりとりを介して処理を行います
- ノードとノード間
- ノードとlaunchシステム間
- ノードとユーザ（コマンドラインインタフェース）間
- コントローラーノードとHWコンポーネント間
  - コントローラーノードとは、ros2_contorlで定義されるクラスを継承して作成されるクラス（ROS2コントローラー）が生成するノードであり、コントローラー管理ノードと同一プロセス中で実行されるノード。このプロセス中にプラグインとして読み込まれるクラスであるHWコンポーネントとコントローラーノードの間でHWへのコマンド送信やHWからの状態の受信が行われる


ノードは情報を入出力する為のIFとして下記の５種類を持ちます

| 情報入出力IF | 自プロセス内のノードとのIF | 他プロセス内のノードとのIF（プロセス間通信） | その他外部IF |
| ---- | ---- | ---- | ---- |
| トピック | 〇：トピック通信（メモリ渡し） | 〇：トピック通信 | - |
| サービス | 〇：サービス通信（メモリ渡し） | 〇：サービス通信 | - |
| アクション | 〇：サービス通信及びトピック通信（メモリ渡し） | 〇：サービス通信及びトピック通信 | - |
| ノードパラメータ | 〇：サービス通信（メモリ渡し） | 〇：サービス通信 | 〇：ROS引数による初期値設定 |
| command interface / state interface | 〇：読み書き（メモリ渡し） | - | - |

command interface / state interface以外は、異なるプロセス上・異なるマシン上のノード間でも情報をやりとりできるのがポイントです。command interfaceやstate interfaceは、ros2_contorolで使用するIFでありプロセス内の情報IFのみを持ちます（pluginによる結合です）

また、自プロセス内のノードとのIFはメモリ渡しになります

初歩的には１ノード=１プロセスとして、プロセスを分けてノードを実行することが多いですが、複数ノードを１プロセスで動作させることで効率的な動作にすることが可能です（プロセス間通信のようなエンコード・UDP通信・デコードが発生しない）。

- さらに、ひと手間加えると受け渡す情報をメモリ上でコピーすることを避けること（＝ゼロコピー）も可能。詳しくは「参考情報」内のリンクを参照

ノードが持つ通信IFによる情報のやりとりを全部羅列すると

- ノードに入ってくる情報

|  | 能動的（通信タイミングは自己決定） | 受動的（通信タイミングは不定） |
|---|---|---|
| トピック | - | サブスクライブしてメッセージを得る |
| サービス | 他ノードのサービスからレスポンスを得る | リクエスト引数を受け取る |
| アクション | 他ノードのアクションから結果を得る | ゴール引数を受け取る・フィードバックを得る |
| パラメータ | 他ノードのパラメータをリードする | ノードパラメータをライトされる/ROS引数によって初期値が設定される |
| state interface | HWコンポーネントからstateを得る | - |

- ノードから出ていく情報

|  | 能動的（通信タイミングは自己決定） | 受動的（通信タイミングは不定） |
|---|---|---|
| トピック | メッセージをパブリッシュする | - |
| サービス | 他ノードにリクエスト引数を渡す | レスポンスを返す |
| アクション | 他ノードにゴール引数を渡す/フィードバックを返す | 結果を返す |
| パラメータ | 他ノードのノードパラメータを書き換える | ノードパラメータをリードされ値を返す |
| command interface | HWコンポーネントにコマンドを送る | - |

# executorとは

- ノードを実行する為のスレッドプールを表すオブジェクト
- 1executor = 1 thread or 複数 thread
- 3種類あり
  - SingleThreadedExecutor
  - MultiThreadedExecutor
  - StaticSingleThreadedExecutor
- 基本的には、1 executable=1 executorだが、 executable内で複数のexecutorを作成することも可能。

# executable/libraryとは
- executable/libraryという概念はROS2特有のものでなく、c/c++の世界（CMake）の用語。ROS2で初めてc++を学び始めた人は、先にCMakeについて学んでおく必要がある。
  - executableもlibraryも、CMakeにおけるbuild targetの単位であり、CMakeist.txt中でビルドする為の情報（使用するソースファイル等）を指定しておき、colcon buildを行うことで生成される。
- executableとは
  - ユーザーもしくは他のexecutableから実行開始可能なプログラム（一群のソースコードから得られる）の単位。
  - エントリーポイントなる関数（通常はmain）を持つ。
  - プロセスとの関係
    - 1 executable = 1 process
- libraryとは
  - executableや他のlibraryからロード可能なプログラム（一群のソースコードから得られる）の単位。
  - エントリーポイントなる関数を持たない。
    - libraryにはクラスを何でも定義できるが、外部から使用して欲しいクラスは所定の方式（=plugin形式）で公開する

## ROS2におけるexecutable
- ノードとの関係
  - 必ずしもノードを動かす必要はないが、基本的にはノードを動かすexecutableを作成し、executableを起動して所定の目的を実現するのがROS2のスタイル。
  - 1 executable = Nノード
    - シンプルなケースでは、1executable = 1ノードで作成することが多いが、複数のノードを実行することもできる。
    - 複数ノードを1 executable(=1 process)上で実行することで、ノード間の通信をプロセス内通信とすることができる。
- 使用方法
  - launchの対象となれる。
  - executableは通常の実行可能プログラムであり、直接コマンドラインから実行・プログラム中から実行も可能であるが、ROS2ではlaunchファイルから実行するのが通常のスタイル

## ROS2におけるlibrary
- ノードとの関係
  - カスタムノードクラスをplugin形式で公開する為に使用する
  - plugin形式の特別な形態としてcomponent形式がある。plugin形式では任意のクラスを公開できるが、component形式で公開できるのはノードクラスだけ。
  - 基本的にROS2では、ノードクラスはpluginでなく全てcomponent形式とすることが推奨されている。
    - [Components vs. Plugins in ROS 2](https://ubuntu.com/blog/components-vs-plugins-in-ros-2)
    - ただし、ros2_cotrolにおけるcontrollerやHW componentは、component形式でなく通常のplugin形式
  - component形式のメリット
    - ノードを同じプロセス内に配置（同じexecutable上に配置）しノード間の通信をプロセス内通信にすることを、簡単に実装できる
    - componentは、自分で作成したexecutable上で実行することもできるが、rclcpp_componentsパッケージ内に標準で用意されているexecutableであるcomponent_containerを使用しても実行できる
  - component形式でノードクラスを公開する方法
    - CMakeLists.txtで`rclcpp_components_register_nodes`を呼ぶ（呼ばない場合通常のplugin形式になる）
- 使用方法
  - libraryがcomponent形式で作成された場合、launchの単位となることが可能
  - libraryは実行可能プログラムではないので、直接コマンドラインから実行・プログラム中から実行はできないが、component形式で作成されていればlaunchファイルから起動できる。
    - その場合、1componentが乗ったexecutableが作成され実行される。


# ROS2におけるパラメータ

ROS2においてパラメータや引数と呼べるモノは複数あります。

※パラメータ(parameter)という用語と引数(argument)という用語は明確に区別せず、動作を決定するために外部から与えられる変という意味で用いています

<caption>表1:ROS2における各種パラメータの一覧</caption>

| 概念 | 目的 | 形式 | 値の型 | 
| ---- | ---- | ---- | ---- |
| ノードパラメータ | ノードの動作を変更する | 名前がついている値の組（key-value dictionary形式） | bool, int64, float64, string, byte[], bool[], int64[], float64[], string[] |
| コマンドラインROS引数 | ノードの初期化処理を制御する | コマンドライン引数 | str |
| グローバルROS引数 | ノードの初期化処理を制御する | `rcl_arguments_impl_s`構造体 | - |
| ローカルROS引数 | ノードの初期化処理を制御する | `rcl_arguments_impl_s`構造体 | - |
| launch引数 | launch fileの動作を変更する | 名前がついている値の組（key-value dictionary形式） | str | 
| xacro実行引数 | URDFの生成時に可変値を与える | 名前がついている値の組（key-value dictionary形式） | str |
| xacroマクロ引数 | マクロの実行時に可変値を与える | 名前がついている値の組（key-value dictionary形式） | int, float, str, bool, list, tuple, dict |

<caption>表2:ROS2における各種パラメータのアクセス性</caption>

| 概念 | 宣言要否 | 読み出し | 書き換え | 初期値 |
| ---- | ---- | ---- | ---- | ---- |
| ノードパラメータ | 原則、明示的に宣言しておいた値のみ受け取れる | 自ノードの値はフィールド参照で読み出し可能。他ノードの値はサービスを使用して読みだし可能（制限することも可能） | 自ノードの値はフィールド参照で書き込み可能。他ノードの値はサービスを使用して書き込み可能（制限することも可能） | executable実行時のコマンドライン引数として初期値を設定可能 |
| コマンドラインROS引数 | 不要 | 自プロセスの値をexecutableのmain関数の引数argvから読み出せる | 不可 | executable実行時のコマンドライン引数として値を指定する |
| グローバルROS引数 | 不要 | 自プロセスの値をグローバルデフォルトコンテキストから読みだせる | 不可 | コマンドラインROS引数から生成される |
| ローカルROS引数 | 不要 | 自ノードの値をフィールド参照で読みだせる | 不可 | executable実装時のコード中（`Node`のconstructorへの引数）で実装する |
| launch引数 | 必要。`DeclareLaunchArgument`アクションで宣言する | launchファイル中のどこでも読み出せる | 不可 | launchコマンドのコマンドライン引数として値を指定する | 
| xacro実行引数 | 必要。`xacro:arg`において`name=`で宣言する | xacroファイル中（includeしたxacroファイル含む）のどこでも読み出せる | 不可 | xacroコマンドのコマンドライン引数として値を指定する |
| xacroマクロ引数 | 必要。`xacro:macro`において `params=`で宣言する | 宣言したマクロ中でのみ読み出せる。 | 不可 | マクロ呼び出し時に値を指定する |


ノードパラメータは単に「パラメータ」と呼ばれることもありますが
この記事では取り違えないようにノードパラメータと呼んでいます。
