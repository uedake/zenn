---
title: "ROS2„ÇíÊ∑±„ÅèÁêÜËß£„Åô„ÇãÔºölaunch„Éï„Ç°„Ç§„É´Á∑®Ôºï„ÄÄLifecycleNode„Ç¢„ÇØ„Ç∑„Éß„É≥"
emoji: "üìë"
type: "tech"
topics:
  - "ros2"
  - "robot"
  - "robotics"
published: true
published_at: "2024-01-20 00:52"
---

# Ëß£Ë™¨ÂØæË±°
Êú¨Ë®ò‰∫ã„Åß„ÅØ„ÄÅROS2„ÅÆlaunchÊ©üËÉΩ„ÅåÊèê‰æõ„Åô„Çã`LifecycleNode`„Ç¢„ÇØ„Ç∑„Éß„É≥„ÇíËß£Ë™¨„Åó„Åæ„Åô„ÄÇ`Node`„Ç¢„ÇØ„Ç∑„Éß„É≥„Å®ÊØî„Åπ„Çã„Å®`LifecycleNode`„Ç¢„ÇØ„Ç∑„Éß„É≥„Åß„ÅØËµ∑ÂãïÂØæË±°„Éé„Éº„Éâ„ÅÆ„É©„Ç§„Éï„Çµ„Ç§„ÇØ„É´„Å´Âπ≤Ê∏â„Åß„Åç„Åì„Å®„ÅåÈÅï„ÅÑ„Åß„Åô„ÄÇ

# ÂâçÊèê
- ROS2 humbleÊôÇ„ÅÆÂÆüË£Ö„Å´Âü∫„Å•„ÅÑ„Å¶„ÅÑ„Åæ„Åô„ÄÇ
- launch„Éï„Ç°„Ç§„É´„ÅÆË®òËø∞„ÅØ„ÄÅpythonÂΩ¢Âºè„ÉªxmlÂΩ¢Âºè„ÉªyamlÂΩ¢Âºè„ÅÆÔºìÂΩ¢Âºè„ÅÆ„Å©„Çå„Åß„ÇÇÂèØËÉΩ„Åß„Åô„Åå„ÄÅÊú¨Ë®ò‰∫ã„ÅØpythonÂΩ¢Âºè„Å´„Å§„ÅÑ„Å¶Ëß£Ë™¨„Åó„Å¶„ÅÑ„Åæ„Åô„ÄÇ
  - ‚Äªlaunch„Éï„Ç°„Ç§„É´„ÅØÁâπÊÆµ„ÅÆÁêÜÁî±„Å™„ÅÑÈôê„ÇäpythonÂΩ¢Âºè„ÅßÊõ∏„Åè„Åπ„Åç„Åß„Åô„ÄÇ„Ç∑„É≥„Éó„É´„Å™ÊßãÊàê„Åß„ÅÇ„Çå„Å∞„Å©„ÅÆÂΩ¢Âºè„Åß„ÇÇË®òËø∞ÂèØËÉΩ„Åß„Åô„Åå„ÄÅË§áÈõë„Å™„Åì„Å®„Çí„Åô„ÇãÂ†¥ÂêàxmlÂΩ¢Âºè„ÉªyamlÂΩ¢Âºè„Åß„ÅØË°å„ÅçË©∞„Åæ„Çä„Åæ„Åô„ÄÇÊúÄÂàù„ÅØËâØ„Åè„Å¶„ÇÇ„Éó„É≠„Ç∏„Çß„ÇØ„Éà„ÅÆÈÄ≤Â±ï„Å´„Çà„Å£„Å¶Âæå„Åã„ÇâË§áÈõë„Å™„Åì„Å®„Çí„Åó„Åü„Åè„Å™„Çã„ÅÆ„ÅåÂ∏∏„Åß„Åô„ÅÆ„Åß„ÄÅlaunch„Éï„Ç°„Ç§„É´„ÅØÊúÄÂàù„Åã„ÇâpythonÂΩ¢Âºè„ÅßÊõ∏„ÅçÂßã„ÇÅ„Çã„Åì„Å®„ÇíÊé®Â•®„Åó„Åæ„Åô„ÄÇ

# ÂâçÊèêÁü•Ë≠ò

- launch„ÅÆÊ¶ÇÂøµ
  - launch„Éï„Ç°„Ç§„É´‰∏≠„Å´„ÄÅ„ÇÑ„Çä„Åü„ÅÑÂá¶ÁêÜÔºàÔºù„Ç¢„ÇØ„Ç∑„Éß„É≥Ôºâ„Çí„ÇÑ„Çä„Åü„ÅÑÈ†ÜÂ∫è„ÅßË®òËºâ„Åô„Çã„ÄÇ

# ÂÖ¨Âºè„Éâ„Ç≠„É•„É°„É≥„Éà
[TBD]

# „ÇΩ„Éº„Çπ„ÅÆÁ¢∫Ë™ç

ÁµêË´ñ„Å†„ÅëÁü•„Çä„Åü„ÅÑ‰∫∫„ÅØÈ£õ„Å∞„Åó„Å¶„Äå„Åæ„Å®„ÇÅ„Äç„Å∏

- `LifecycleNode`„Ç¢„ÇØ„Ç∑„Éß„É≥„ÅÆ„ÇΩ„Éº„Çπ„Çí„Åø„Å¶„Åø„Åæ„Åô„ÄÇ„Åæ„Åö„ÅØ`__init__()`„ÇíË¶ã„Å¶„Åø„Åæ„Åó„Çá„ÅÜ„ÄÇ
  - Âçò„Å´Ë¶™„ÇØ„É©„Çπ„Åß„ÅÇ„Çã`Node`„Ç¢„ÇØ„Ç∑„Éß„É≥„ÅÆ`__init__()`„Çí‰ΩøÁî®„Åó„Å¶„Çã„Å†„Åë„ÅÆ„Çà„ÅÜ„Åß„Åô

[lifecycle_node.py](https://github.com/ros2/launch_ros/blob/humble/launch_ros/launch_ros/actions/lifecycle_node.py)

```py:lifecycle_node.py
class LifecycleNode(Node):
    """Action that executes a ROS lifecycle node."""

    def __init__(
        self,
        *,
        name: SomeSubstitutionsType,
        namespace: SomeSubstitutionsType,
        **kwargs
    ) -> None:

        # Áï•

        super().__init__(name=name, namespace=namespace, **kwargs)
        self.__logger = launch.logging.get_logger(__name__)
        self.__rclpy_subscription = None
        self.__current_state = \
            ChangeState.valid_states[lifecycle_msgs.msg.State.PRIMARY_STATE_UNKNOWN]

```

- Ê¨°„Å´„Ç¢„ÇØ„Ç∑„Éß„É≥„ÅÆÂÆüË°åÊôÇ„ÅÆÂá¶ÁêÜ„Åß„ÅÇ„Çã`execute()`„ÅÆÂÆüË£ÖÂèä„Å≥‰ΩøÁî®„Åï„Çå„Å¶„ÅÑ„Çã`get_ros_node()`„ÅÆÂÆüË£Ö„ÇíË¶ã„Å¶„Åø„Åæ„Åô„ÄÇ‰∏ãË®ò„ÅÆÊµÅ„Çå„Å´„Å™„Å£„Å¶„ÅÑ„Çã„Åì„Å®„Åå„Çè„Åã„Çä„Åæ„Åô„ÄÇ
  1. „Éé„Éº„ÉâÂêç„ÅåÊåáÂÆö„Åï„Çå„Å¶„ÅÑ„Çã„ÉÅ„Çß„ÉÉ„ÇØ
      - `LifecycleNode`„Ç¢„ÇØ„Ç∑„Éß„É≥„ÅØ`Node`„Ç¢„ÇØ„Ç∑„Éß„É≥„Å®Áï∞„Å™„Çä„ÄÅËµ∑ÂãïÂØæË±°„Éé„Éº„Éâ„ÅÆ„Éé„Éº„ÉâÂêç„ÅÆÊåáÂÆöÔºà`__init__()`„Åß„ÅÆ`name`„ÅÆÊåáÂÆöÔºâ„ÅåÂøÖÈ†à„Å®„Å™„Å£„Å¶„ÅÑ„Çã
      - „Çà„Å£„Å¶node„ÇíË§áÊï∞ÂÄãËµ∑Âãï„Åô„Çã„Çà„ÅÜ„Å™executable„ÅÆÂÆüË°å„Å´`LifecycleNode`„Ç¢„ÇØ„Ç∑„Éß„É≥„Çí‰ΩøÁî®„Åô„Çã„Åì„Å®„ÅØÊÉ≥ÂÆö„Åï„Çå„Å¶„ÅÑ„Å™„ÅÑÊßòÂ≠ê
  2. `get_ros_node()`„Åßlaunch_ros„Éé„Éº„Éâ„ÇíÂæó„Çã
      - `get_ros_node()`„ÅØ`LaunchContext`ÊØé„Å´„Åü„Å†Ôºë„Å§Â≠òÂú®„Åô„Çã`ROSAdapter`„ÇØ„É©„Çπ„ÇíÂæó„ÇãÈñ¢Êï∞„Åß„ÅôÔºàÂàù„ÇÅ„Å¶Âëº„Å∞„Çå„ÅüÂ†¥Âêà„ÅØ`ROSAdapter`„ÇØ„É©„Çπ„ÇíÁîüÊàê„Åô„ÇãÔºâ
      - `ROSAdapter`„ÇØ„É©„Çπ„ÅØ„ÄÅ`__init__()`ÊôÇ„Å´`Node`„ÇØ„É©„Çπ„Åã„Çâ„Éé„Éº„Éâ„ÇíÔºë„Å§ÁîüÊàêÔºà„Éé„Éº„ÉâÂêç„ÅØ`'launch_ros_{}'.format(os.getpid())`Ôºâ„Åóexecutor‰∏ä„Åß„Éé„Éº„Éâ„ÇíÂÆüË°å„Åó„Åæ„Åô„ÄÇ
      - „Åì„ÅÆ„Éé„Éº„Éâ„ÅØlaunch„Éï„Ç°„Ç§„É´„ÅÆ`OnShutdown`„Ç§„Éô„É≥„Éà„ÅåÂëº„Å∞„Çå„Åü„Çø„Ç§„Éü„É≥„Ç∞„ÅßÁµÇ‰∫Ü„Åó„Åæ„Åô
      - „Å§„Åæ„Çä„ÄÅlaunch„Ç∑„Çπ„ÉÜ„É†„ÅØ„ÄÅ„É¶„Éº„Ç∂„Éº„ÅåÊÑèÂõ≥ÁöÑ„Å´Ëµ∑Âãï„Åô„Çã„Éé„Éº„ÉâÔºàÊåáÂÆö„ÅÆexecutable„ÅßÁîüÊàê„Åï„Çå„ÇãÔºâ‰ª•Â§ñ„Å´Ôºë„Å§„ÅÆ„Éé„Éº„Éâ„ÇíË£è„ÅßËµ∑Âãï„Åó„Åæ„Åô
      - „Åì„ÅÆ„Éé„Éº„Éâ„ÇíÊú¨Ë®ò‰∫ã„Åß„ÅØlaunch_ros„Éé„Éº„Éâ„Å®Âëº„Å≥„Åæ„Åô
  3. launch_ros„Éé„Éº„Éâ„Å´„Éà„Éî„ÉÉ„ÇØ„Çµ„Éñ„Çπ„ÇØ„É™„Éó„Ç∑„Éß„É≥„ÇíË®≠ÂÆö
      - Ëµ∑ÂãïÂØæË±°„Éé„Éº„Éâ„ÅÆ„É©„Ç§„Éï„Çµ„Ç§„ÇØ„É´Áä∂ÊÖã„ÅåÂ§âÂåñ„Åó„ÅüÊôÇ„Å´Áô∫Âá∫„Åï„Çå„Çã`TransitionEvent`„É°„ÉÉ„Çª„Éº„Ç∏„ÇíÂèó‰ø°„Åô„Çã„Çà„ÅÜ„Éà„Éî„ÉÉ„ÇØ„Çµ„Éñ„Çπ„ÇØ„É™„Éó„Ç∑„Éß„É≥„Çílaunch_ros„Éé„Éº„Éâ„Å´Ë®≠ÂÆö
        - launch_ros„Éé„Éº„Éâ„ÅØ„ÄÅ`TransitionEvent`„É°„ÉÉ„Çª„Éº„Ç∏Âèó‰ø°ÊôÇ„Å´„ÄÅlaunch„Ç∑„Çπ„ÉÜ„É†‰∏ä„Åß`StateTransition`„Ç§„Éô„É≥„Éà„ÇíÁô∫Ë°å„Åô„Çã
  4. launch_ros„Éé„Éº„Éâ„Å´„Çµ„Éº„Éì„Çπ„ÇØ„É©„Ç§„Ç¢„É≥„Éà„ÇíË®≠ÂÆö
      - Ëµ∑ÂãïÂØæË±°„Éé„Éº„Éâ„ÅÆ`ChangeState`„Çµ„Éº„Éì„Çπ„Çí„É™„ÇØ„Ç®„Çπ„ÉàÔºà„É©„Ç§„Éï„Çµ„Ç§„ÇØ„É´Áä∂ÊÖã„ÅÆÂ§âÂåñ„Çí„Éà„É™„Ç¨„Éº„Åô„ÇãÔºâ„Åô„ÇãÁÇ∫„ÅÆ„Çµ„Éº„Éì„Çπ„ÇØ„É©„Ç§„Ç¢„É≥„Éà„Çílaunch_ros„Éé„Éº„Éâ„Å´Ë®≠ÂÆö
  5. launch„Ç∑„Çπ„ÉÜ„É†‰∏ä„ÅÆ„Ç§„Éô„É≥„Éà„Éè„É≥„Éâ„É©„ÇíË®≠ÂÆö
      - launch„Ç∑„Çπ„ÉÜ„É†‰∏ä„Åß`ChangeState`„Ç§„Éô„É≥„Éà„ÅåÁô∫Ë°å„Åï„Çå„Åü„Å®„Åç„Å´Ë°å„ÅÜÂá¶ÁêÜ„Å®„Åó„Å¶„ÄÅ4„ÅÆ„Çµ„Éº„Éì„Çπ„ÇØ„É©„Ç§„Ç¢„É≥„Éà„ÇíÁî®„ÅÑ„Å¶`ChangeState`„Çµ„Éº„Éì„Çπ„Çí„É™„ÇØ„Ç®„Çπ„Éà„Åô„Çã„Éè„É≥„Éâ„É©„ÇíË®≠ÂÆö

[lifecycle_node.py](https://github.com/ros2/launch_ros/blob/humble/launch_ros/launch_ros/actions/lifecycle_node.py)

```py:lifecycle_node.py
class LifecycleNode(Node):

        # Áï•

    def _on_transition_event(self, context, msg):
        try:
            event = StateTransition(action=self, msg=msg)
            self.__current_state = ChangeState.valid_states[msg.goal_state.id]
            context.asyncio_loop.call_soon_threadsafe(lambda: context.emit_event_sync(event))
        except Exception as exc:
            self.__logger.error(
                "Exception in handling of 'lifecycle.msg.TransitionEvent': {}".format(exc))

    def _call_change_state(self, request, context: launch.LaunchContext):
        while not self.__rclpy_change_state_client.wait_for_service(timeout_sec=1.0):
            if context.is_shutdown:
                self.__logger.warning(
                    "Abandoning wait for the '{}' service, due to shutdown.".format(
                        self.__rclpy_change_state_client.srv_name),
                )
                return

        # Asynchronously wait so that we can periodically check for shutdown.
        event = threading.Event()

        def unblock(future):
            nonlocal event
            event.set()

        response_future = self.__rclpy_change_state_client.call_async(request)
        response_future.add_done_callback(unblock)

        while not event.wait(1.0):
            if context.is_shutdown:
                self.__logger.warning(
                    "Abandoning wait for the '{}' service response, due to shutdown.".format(
                        self.__rclpy_change_state_client.srv_name),
                )
                response_future.cancel()
                return

        if response_future.exception() is not None:
            raise response_future.exception()
        response = response_future.result()

        if not response.success:
            self.__logger.error(
                "Failed to make transition '{}' for LifecycleNode '{}'".format(
                    ChangeState.valid_transitions[request.transition.id],
                    self.node_name,
                )
            )

    def _on_change_state_event(self, context: launch.LaunchContext) -> None:
        typed_event = cast(ChangeState, context.locals.event)
        if not typed_event.lifecycle_node_matcher(self):
            return None
        request = lifecycle_msgs.srv.ChangeState.Request()
        request.transition.id = typed_event.transition_id
        context.add_completion_future(
            context.asyncio_loop.run_in_executor(None, self._call_change_state, request, context))

    def execute(self, context: launch.LaunchContext) -> Optional[List[Action]]:
        """
        Execute the action.

        Delegated to :meth:`launch.actions.ExecuteProcess.execute`.
        """
        self._perform_substitutions(context)  # ensure self.node_name is expanded
        if '<node_name_unspecified>' in self.node_name:
            raise RuntimeError('node_name unexpectedly incomplete for lifecycle node')
        node = get_ros_node(context)
        # Create a subscription to monitor the state changes of the subprocess.
        self.__rclpy_subscription = node.create_subscription(
            lifecycle_msgs.msg.TransitionEvent,
            '{}/transition_event'.format(self.node_name),
            functools.partial(self._on_transition_event, context),
            10)
        # Create a service client to change state on demand.
        self.__rclpy_change_state_client = node.create_client(
            lifecycle_msgs.srv.ChangeState,
            '{}/change_state'.format(self.node_name))
        # Register an event handler to change states on a ChangeState lifecycle event.
        context.register_event_handler(launch.EventHandler(
            matcher=lambda event: isinstance(event, ChangeState),
            entities=[launch.actions.OpaqueFunction(function=self._on_change_state_event)],
        ))
        # Delegate execution to Node and ExecuteProcess.
        return super().execute(context)
```

[ros_adapters.py](https://github.com/ros2/launch_ros/blob/humble/launch_ros/launch_ros/ros_adapters.py)

```py:ros_adapters.py
def get_ros_adapter(context: launch.LaunchContext):
    """
    Get the ROS adapter managed by the given launch context.

    If no adapter is found, one will be created.

    This function is reentrant but concurrent calls on the
    same `context` are not safe.
    """
    if not hasattr(context.locals, 'ros_adapter'):
        ros_adapter = ROSAdapter()
        context.extend_globals({'ros_adapter': ros_adapter})
        context.register_event_handler(launch.event_handlers.OnShutdown(
            on_shutdown=lambda *args, **kwargs: ros_adapter.shutdown()
        ))
    return context.locals.ros_adapter


def get_ros_node(context: launch.LaunchContext):
    """
    Get the ROS node managed by the given launch context.

    If no node is found, one will be created.

    This function is reentrant but concurrent calls on the
    same `context` are not safe.
    """
    return get_ros_adapter(context).ros_node
```

# „Åæ„Å®„ÇÅ

- `LifecycleNode`„Ç¢„ÇØ„Ç∑„Éß„É≥„ÅØ`Node`„Ç¢„ÇØ„Ç∑„Éß„É≥„ÇíÁ∂ôÊâø„Åó„Å¶„ÅÑ„Çã„ÅÆ„Åß„ÄÅ`Node`„Ç¢„ÇØ„Ç∑„Éß„É≥„Åß„Åß„Åç„Çã„Åì„Å®„ÅØÂÖ®„Å¶„Åß„Åç„Åæ„Åô
- Âä†„Åà„Å¶Ëµ∑ÂãïÂØæË±°„Éé„Éº„Éâ„ÅÆ„É©„Ç§„Éï„Çµ„Ç§„ÇØ„É´„Å´Âπ≤Ê∏â„Åß„Åç„Åæ„Åô
  - Ëµ∑ÂãïÂØæË±°„Éé„Éº„Éâ„ÅÆ„É©„Ç§„Éï„Çµ„Ç§„ÇØ„É´Áä∂ÊÖã„ÅåÂ§âÊõ¥„Åï„Çå„ÅüÊôÇ„Å´„ÄÅlaunch„Ç∑„Çπ„ÉÜ„É†‰∏ä„ÅÆ`StateTransition`„Ç§„Éô„É≥„Éà„ÅåÁô∫Âá∫„Åï„Çå„Çã„Çà„ÅÜ„Å´„Å™„Çã
    - „Åì„Çå„Å´„Çà„Çä„ÄÅlaunch„Ç∑„Çπ„ÉÜ„É†‰∏ä„Åß„Ç§„Éô„É≥„Éà„Éè„É≥„Éâ„É©„ÇíË®≠ÂÆö„Åó„Å¶„Åä„Åë„Å∞„ÄÅËµ∑ÂãïÂØæË±°„Éé„Éº„Éâ„ÅÆÁä∂ÊÖãÈÅ∑Áßª„ÅåÂÆå‰∫Ü„Åó„Åü„Çâ„Äá„Äá„Çí„Åô„ÇãÔºà‰æãÔºö‰ªñ„ÅÆ„Éé„Éº„Éâ„ÇíËµ∑Âãï„Åô„Çã„Ç¢„ÇØ„Ç∑„Éß„É≥„ÇíÂÆüË°å„Åô„ÇãÔºâ„Å®„ÅÑ„ÅÜË®òËø∞„ÅåÂèØËÉΩ„Å´„Å™„Çã
  - Ëµ∑ÂãïÂØæË±°„Éé„Éº„Éâ„ÅÆ„É©„Ç§„Éï„Çµ„Ç§„ÇØ„É´Áä∂ÊÖã„ÇíÂ§âÊõ¥„Åô„ÇãÁÇ∫„ÅÆ„ÄÅ`ChangeState`„Ç§„Éô„É≥„Éà„Éè„É≥„Éâ„É©„ÇíÁôªÈå≤„Åô„Çã
    - „Åì„Çå„Å´„Çà„Çä„ÄÅlaunch„Ç∑„Çπ„ÉÜ„É†‰∏ä„Åß`ChangeState`„Ç§„Éô„É≥„Éà„ÇíÁô∫Ë°å„Åô„Çå„Å∞Ëµ∑ÂãïÂØæË±°„Éé„Éº„Éâ„ÅÆ„É©„Ç§„Éï„Çµ„Ç§„ÇØ„É´Áä∂ÊÖã„ÇíÈÅ∑Áßª„Åï„Åõ„Çâ„Çå„Çã
- „Åü„Å†„Åó‰∏ãË®ò„ÅÆÂà∂Èôê„Åå„ÅÇ„Çä„Åæ„Åô
  - ÂØæË±°„Å®„Åô„Çãexecutable„ÅåËµ∑Âãï„Åô„Çã„Éé„Éº„Éâ„ÅØÔºë„Å§ÔºàË§áÊï∞„Éé„Éº„Éâ„ÇíËµ∑Âãï„Åô„ÇãexecutableÂêë„Åë„Åß„ÅØ„Å™„ÅÑÔºâ

`Node`„Ç¢„ÇØ„Ç∑„Éß„É≥„Å®„ÅÆ‰Ωø„ÅÑÂàÜ„Åë„ÅØ‰∏ãË®ò„ÅÆÈÄö„Çä

|„Ç¢„ÇØ„Ç∑„Éß„É≥Âêç|Ëµ∑Âãï„Åß„Åç„Çãexecutable|‰Ωø„ÅÑ„Å©„Åì„Çç|
|-|-|-|
|`Node`|„Éé„Éº„ÉâÔºà`Node`„Éª`LifecycleNode`Âèä„Å≥„Åù„Çå„Çâ„ÅÆÊ¥æÁîüÔºâ„ÇíÔºë~Ë§áÊï∞ÂÄãËµ∑Âãï„Åô„Çãexecutable|„É©„Ç§„Éï„Çµ„Ç§„ÇØ„É´„Å´Âπ≤Ê∏â„Åô„ÇãÂøÖË¶Å„Åå„Å™„ÅÑÂ†¥Âêà„ÅØ„Åì„Å£„Å°|
|`LifecycleNode`|„É©„Ç§„Éï„Çµ„Ç§„ÇØ„É´„Éé„Éº„ÉâÔºà`LifecycleNode`Âèä„Å≥„Åù„ÅÆÊ¥æÁîüÔºâ„Çí1„Å§Ëµ∑Âãï„Åô„Çãexecutable|„É©„Ç§„Éï„Çµ„Ç§„ÇØ„É´„Å´Âπ≤Ê∏â„Åó„Åü„ÅÑÂ†¥Âêà„ÅÆ„Åø„Åì„Å£„Å°|

„É©„Ç§„Éï„Çµ„Ç§„ÇØ„É´„Éé„Éº„Éâ„ÇíËµ∑Âãï„Åó„Åü„ÅÑÂ†¥Âêà„Åß„ÇÇÂü∫Êú¨ÁöÑ„Å´„ÅØ`Node`„Ç¢„ÇØ„Ç∑„Éß„É≥„Çí‰Ωø„Åà„Å∞„Çà„Åè„ÄÅ`LifecycleNode`„Ç¢„ÇØ„Ç∑„Éß„É≥„ÅåÂøÖË¶Å„Å™„Ç±„Éº„Çπ„ÅØÈôê„Çâ„Çå„Åæ„Åô

