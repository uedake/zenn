---
title: "ROS2„ÇíÊ∑±„ÅèÁêÜËß£„Åô„ÇãÔºölaunch„Éï„Ç°„Ç§„É´Á∑®Ôºï„ÄÄLifecycleNode„Ç¢„ÇØ„Ç∑„Éß„É≥"
emoji: "üìë"
type: "tech"
topics:
  - "ros2"
  - "robot"
  - "robotics"
published: false
---

# Ëß£Ë™¨ÂØæË±°
Êú¨Ë®ò‰∫ã„Åß„ÅØ„ÄÅROS2„ÅÆlaunchÊ©üËÉΩ„ÅåÊèê‰æõ„Åô„Çã`LifecycleNode`„Ç¢„ÇØ„Ç∑„Éß„É≥„ÇíËß£Ë™¨„Åó„Åæ„Åô„ÄÇ`Node`„Ç¢„ÇØ„Ç∑„Éß„É≥„Å®„ÅÆÈÅï„ÅÑ„ÅØ`LifecycleNode`ÁâπÊúâ„ÅÆÂºïÊï∞„Åå‰Ωø„Åà„Çã„Åì„Å®„Åß„Åô„ÄÇ

# ÂâçÊèê
- ROS2 humbleÊôÇ„ÅÆÂÆüË£Ö„Å´Âü∫„Å•„ÅÑ„Å¶„ÅÑ„Åæ„Åô„ÄÇ
- launch„Éï„Ç°„Ç§„É´„ÅÆË®òËø∞„ÅØ„ÄÅpythonÂΩ¢Âºè„ÉªxmlÂΩ¢Âºè„ÉªyamlÂΩ¢Âºè„ÅÆÔºìÂΩ¢Âºè„ÅÆ„Å©„Çå„Åß„ÇÇÂèØËÉΩ„Åß„Åô„Åå„ÄÅÊú¨Ë®ò‰∫ã„ÅØpythonÂΩ¢Âºè„Å´„Å§„ÅÑ„Å¶Ëß£Ë™¨„Åó„Å¶„ÅÑ„Åæ„Åô„ÄÇ
  - ‚Äªlaunch„Éï„Ç°„Ç§„É´„ÅØÁâπÊÆµ„ÅÆÁêÜÁî±„Å™„ÅÑÈôê„ÇäpythonÂΩ¢Âºè„ÅßÊõ∏„Åè„Åπ„Åç„Åß„Åô„ÄÇ„Ç∑„É≥„Éó„É´„Å™ÊßãÊàê„Åß„ÅÇ„Çå„Å∞„Å©„ÅÆÂΩ¢Âºè„Åß„ÇÇË®òËø∞ÂèØËÉΩ„Åß„Åô„Åå„ÄÅË§áÈõë„Å™„Åì„Å®„Çí„Åô„ÇãÂ†¥ÂêàxmlÂΩ¢Âºè„ÉªyamlÂΩ¢Âºè„Åß„ÅØË°å„ÅçË©∞„Åæ„Çä„Åæ„Åô„ÄÇÊúÄÂàù„ÅØËâØ„Åè„Å¶„ÇÇ„Éó„É≠„Ç∏„Çß„ÇØ„Éà„ÅÆÈÄ≤Â±ï„Å´„Çà„Å£„Å¶Âæå„Åã„ÇâË§áÈõë„Å™„Åì„Å®„Çí„Åó„Åü„Åè„Å™„Çã„ÅÆ„ÅåÂ∏∏„Åß„Åô„ÅÆ„Åß„ÄÅlaunch„Éï„Ç°„Ç§„É´„ÅØÊúÄÂàù„Åã„ÇâpythonÂΩ¢Âºè„ÅßÊõ∏„ÅçÂßã„ÇÅ„Çã„Åì„Å®„ÇíÊé®Â•®„Åó„Åæ„Åô„ÄÇ

# ÂâçÊèêÁü•Ë≠ò

- launch„ÅÆÊ¶ÇÂøµ
  - launch„Éï„Ç°„Ç§„É´‰∏≠„Å´„ÄÅ„ÇÑ„Çä„Åü„ÅÑÂá¶ÁêÜÔºàÔºù„Ç¢„ÇØ„Ç∑„Éß„É≥Ôºâ„Çí„ÇÑ„Çä„Åü„ÅÑÈ†ÜÂ∫è„ÅßË®òËºâ„Åô„Çã„ÄÇ

# ÂÖ¨Âºè„Éâ„Ç≠„É•„É°„É≥„Éà
[TBD]

# „ÇΩ„Éº„Çπ„ÅÆÁ¢∫Ë™ç

ÁµêË´ñ„Å†„ÅëÁü•„Çä„Åü„ÅÑ‰∫∫„ÅØÈ£õ„Å∞„Åó„Å¶„Äå„Åæ„Å®„ÇÅ„Äç„Å∏

- `LifecycleNode`„Ç¢„ÇØ„Ç∑„Éß„É≥„ÅÆ„ÇΩ„Éº„Çπ„Çí„Åø„Å¶„Åø„Åæ„Åô„ÄÇ„Åæ„Åö„ÅØ`__init__()`„ÇíË¶ã„Å¶„Åø„Åæ„Åó„Çá„ÅÜ„ÄÇ
  - Âçò„Å´Ë¶™„ÇØ„É©„Çπ„Åß„ÅÇ„Çã`Node`„Ç¢„ÇØ„Ç∑„Éß„É≥„ÅÆ`__init__()`„Çí‰ΩøÁî®„Åó„Å¶„Çã„Å†„Åë„ÅÆ„Çà„ÅÜ„Åß„Åô

[lifecycle_node.py](https://github.com/ros2/launch_ros/blob/humble/launch_ros/launch_ros/actions/lifecycle_node.py)

```py:lifecycle_node.py
class LifecycleNode(Node):
    """Action that executes a ROS lifecycle node."""

    def __init__(
        self,
        *,
        name: SomeSubstitutionsType,
        namespace: SomeSubstitutionsType,
        **kwargs
    ) -> None:

        # Áï•

        super().__init__(name=name, namespace=namespace, **kwargs)
        self.__logger = launch.logging.get_logger(__name__)
        self.__rclpy_subscription = None
        self.__current_state = \
            ChangeState.valid_states[lifecycle_msgs.msg.State.PRIMARY_STATE_UNKNOWN]

```

- Ê¨°„Å´„Ç¢„ÇØ„Ç∑„Éß„É≥„ÅÆÂÆüË°åÊôÇ„ÅÆÂá¶ÁêÜ„Åß„ÅÇ„Çã`execute()`„ÅÆÂÆüË£ÖÂèä„Å≥‰ΩøÁî®„Åï„Çå„Å¶„ÅÑ„Çã`get_ros_node()`„ÅÆÂÆüË£Ö„ÇíË¶ã„Å¶„Åø„Åæ„Åô„ÄÇ‰∏ãË®ò„ÅÆÊµÅ„Çå„Å´„Å™„Å£„Å¶„ÅÑ„Çã„Åì„Å®„Åå„Çè„Åã„Çä„Åæ„Åô„ÄÇ
  1. nodeÂêç„ÅåÊåáÂÆö„Åï„Çå„Å¶„ÅÑ„Çã„ÉÅ„Çß„ÉÉ„ÇØ
      - `LifecycleNode`„Ç¢„ÇØ„Ç∑„Éß„É≥„ÅØ`Node`„Ç¢„ÇØ„Ç∑„Éß„É≥„Å®Áï∞„Å™„Çä„ÄÅnodeÂêç„ÅÆÊåáÂÆöÔºà`__init__()`„Åß„ÅÆ`name`„ÅÆÊåáÂÆöÔºâ„ÅåÂøÖÈ†à„Å®„Å™„Å£„Å¶„ÅÑ„Çã
      - „Çà„Å£„Å¶node„ÇíË§áÊï∞ÂÄãËµ∑Âãï„Åô„Çã„Çà„ÅÜ„Å™executable„ÅÆÂÆüË°å„Å´`LifecycleNode`„Ç¢„ÇØ„Ç∑„Éß„É≥„Çí‰ΩøÁî®„Åô„Çã„Åì„Å®„ÅØÊÉ≥ÂÆö„Åï„Çå„Å¶„ÅÑ„Å™„ÅÑÊßòÂ≠ê
  2. `get_ros_node()`„Åßlaunch_ros„Éé„Éº„Éâ„ÇíÂæó„Çã
      - `get_ros_node()`„ÅØ`LaunchContext`ÊØé„Å´„Åü„Å†Ôºë„Å§Â≠òÂú®„Åô„Çã`ROSAdapter`„ÇØ„É©„Çπ„ÇíÂæó„ÇãÈñ¢Êï∞„Åß„ÅôÔºàÂàù„ÇÅ„Å¶Âëº„Å∞„Çå„ÅüÂ†¥Âêà„ÅØ`ROSAdapter`„ÇØ„É©„Çπ„ÇíÁîüÊàê„Åô„ÇãÔºâ
      - `ROSAdapter`„ÇØ„É©„Çπ„ÅØ„ÄÅ`__init__()`ÊôÇ„Å´Node„ÇíÔºë„Å§ÁîüÊàêÔºànodeÂêç„ÅØ`'launch_ros_{}'.format(os.getpid())`Ôºâ„Åóexecutor‰∏ä„Åß`Node`„ÇíÂÆüË°å„Åó„Åæ„Åô„ÄÇ
      - „Åì„ÅÆ`Node`„ÅØlaunch„Éï„Ç°„Ç§„É´„ÅÆ`OnShutdown`„Ç§„Éô„É≥„Éà„ÅåÂëº„Å∞„Çå„Åü„Çø„Ç§„Éü„É≥„Ç∞„ÅßÁµÇ‰∫Ü„Åó„Åæ„Åô
      - „Å§„Åæ„Çä„ÄÅlaunch„Ç∑„Çπ„ÉÜ„É†„ÅØ„ÄÅ„É¶„Éº„Ç∂„Éº„ÅåÊÑèÂõ≥ÁöÑ„Å´Ëµ∑Âãï„Åô„ÇãnodeÔºàÊåáÂÆö„ÅÆexecutable„ÅßÁîüÊàê„Åï„Çå„ÇãÔºâ‰ª•Â§ñ„Å´Ôºë„Å§„ÅÆnode„ÇíË£è„ÅßËµ∑Âãï„Åó„Åæ„Åô
      - „Åì„ÅÆnode„ÇíÊú¨Ë®ò‰∫ã„Åß„ÅØlaunch_ros„Éé„Éº„Éâ„Å®Âëº„Å≥„Åæ„Åô
  3. launch_ros„Éé„Éº„Éâ„Å´topic„ÅÆsubscription„Å®service„ÅÆclient„ÇíË®≠ÂÆö
      - 

[lifecycle_node.py](https://github.com/ros2/launch_ros/blob/humble/launch_ros/launch_ros/actions/lifecycle_node.py)

```py:lifecycle_node.py
class LifecycleNode(Node):

        # Áï•

    def _on_transition_event(self, context, msg):
        try:
            event = StateTransition(action=self, msg=msg)
            self.__current_state = ChangeState.valid_states[msg.goal_state.id]
            context.asyncio_loop.call_soon_threadsafe(lambda: context.emit_event_sync(event))
        except Exception as exc:
            self.__logger.error(
                "Exception in handling of 'lifecycle.msg.TransitionEvent': {}".format(exc))

    def _call_change_state(self, request, context: launch.LaunchContext):
        while not self.__rclpy_change_state_client.wait_for_service(timeout_sec=1.0):
            if context.is_shutdown:
                self.__logger.warning(
                    "Abandoning wait for the '{}' service, due to shutdown.".format(
                        self.__rclpy_change_state_client.srv_name),
                )
                return

        # Asynchronously wait so that we can periodically check for shutdown.
        event = threading.Event()

        def unblock(future):
            nonlocal event
            event.set()

        response_future = self.__rclpy_change_state_client.call_async(request)
        response_future.add_done_callback(unblock)

        while not event.wait(1.0):
            if context.is_shutdown:
                self.__logger.warning(
                    "Abandoning wait for the '{}' service response, due to shutdown.".format(
                        self.__rclpy_change_state_client.srv_name),
                )
                response_future.cancel()
                return

        if response_future.exception() is not None:
            raise response_future.exception()
        response = response_future.result()

        if not response.success:
            self.__logger.error(
                "Failed to make transition '{}' for LifecycleNode '{}'".format(
                    ChangeState.valid_transitions[request.transition.id],
                    self.node_name,
                )
            )

    def _on_change_state_event(self, context: launch.LaunchContext) -> None:
        typed_event = cast(ChangeState, context.locals.event)
        if not typed_event.lifecycle_node_matcher(self):
            return None
        request = lifecycle_msgs.srv.ChangeState.Request()
        request.transition.id = typed_event.transition_id
        context.add_completion_future(
            context.asyncio_loop.run_in_executor(None, self._call_change_state, request, context))

    def execute(self, context: launch.LaunchContext) -> Optional[List[Action]]:
        """
        Execute the action.

        Delegated to :meth:`launch.actions.ExecuteProcess.execute`.
        """
        self._perform_substitutions(context)  # ensure self.node_name is expanded
        if '<node_name_unspecified>' in self.node_name:
            raise RuntimeError('node_name unexpectedly incomplete for lifecycle node')
        node = get_ros_node(context)
        # Create a subscription to monitor the state changes of the subprocess.
        self.__rclpy_subscription = node.create_subscription(
            lifecycle_msgs.msg.TransitionEvent,
            '{}/transition_event'.format(self.node_name),
            functools.partial(self._on_transition_event, context),
            10)
        # Create a service client to change state on demand.
        self.__rclpy_change_state_client = node.create_client(
            lifecycle_msgs.srv.ChangeState,
            '{}/change_state'.format(self.node_name))
        # Register an event handler to change states on a ChangeState lifecycle event.
        context.register_event_handler(launch.EventHandler(
            matcher=lambda event: isinstance(event, ChangeState),
            entities=[launch.actions.OpaqueFunction(function=self._on_change_state_event)],
        ))
        # Delegate execution to Node and ExecuteProcess.
        return super().execute(context)
```

[ros_adapters.py](https://github.com/ros2/launch_ros/blob/humble/launch_ros/launch_ros/ros_adapters.py)

```py:ros_adapters.py
def get_ros_adapter(context: launch.LaunchContext):
    """
    Get the ROS adapter managed by the given launch context.

    If no adapter is found, one will be created.

    This function is reentrant but concurrent calls on the
    same `context` are not safe.
    """
    if not hasattr(context.locals, 'ros_adapter'):
        ros_adapter = ROSAdapter()
        context.extend_globals({'ros_adapter': ros_adapter})
        context.register_event_handler(launch.event_handlers.OnShutdown(
            on_shutdown=lambda *args, **kwargs: ros_adapter.shutdown()
        ))
    return context.locals.ros_adapter


def get_ros_node(context: launch.LaunchContext):
    """
    Get the ROS node managed by the given launch context.

    If no node is found, one will be created.

    This function is reentrant but concurrent calls on the
    same `context` are not safe.
    """
    return get_ros_adapter(context).ros_node
```

# „Åæ„Å®„ÇÅ

